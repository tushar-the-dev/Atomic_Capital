<script>
  document.addEventListener("DOMContentLoaded", () => {
    const navs = document.querySelectorAll(".nav-link-wrapper");

    navs.forEach((nav) => {
      const navDot = nav.querySelector(".nav-link-dot");
      const dropdown = nav.querySelector(".nav-link-dropdown");

      // Measure actual content height
      const height = dropdown.scrollHeight;
      dropdown.style.setProperty("--menu-height", height + "px");

      nav.addEventListener("mouseenter", () => {
        dropdown.classList.add("is-open");
        navDot.classList.add("active");
      });

      nav.addEventListener("mouseleave", () => {
        dropdown.classList.remove("is-open");
        navDot.classList.remove("active");
      });

      // Optional: recalc on resize
      window.addEventListener("resize", () => {
        const newHeight = dropdown.scrollHeight;
        dropdown.style.setProperty("--menu-height", newHeight + "px");
      });
    });

    // line height
    var complete_height = gsap.utils.toArray("[vertical-line-fill]");
    complete_height.forEach(function (element) {
      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: element,
          start: "top 95%",
          end: "bottom -60%",
          scrub: true,
        },
      });
      tl.fromTo(
        element,
        { height: 0 },
        { duration: 2, height: "100%", ease: "cubic" }
      );
    });
  });

  // Beyond Capital Cards
  document.addEventListener("DOMContentLoaded", () => {
    const cards = document.querySelectorAll(".beyond-capital-grid-item");

    cards.forEach((card) => {
      const video = card.querySelector(".beyond-cap-grid-item-icon video");
      // Play on hover
      card.addEventListener("mouseenter", () => {
        video.play();
      });

      // Pause & reset on hover out
      card.addEventListener("mouseleave", () => {
        video.pause();
        video.currentTime = 0;
      });
    });
  });

  document.addEventListener("DOMContentLoaded", () => {
    const video = document.querySelector(".atomic-animation video");
    if (!video) return;

    let hasPlayed = false;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !hasPlayed) {
            video.play().catch(() => {});
            hasPlayed = true;
            observer.disconnect(); // stop observing forever
          }
        });
      },
      {
        threshold: 0.5, // 50% visible
      }
    );

    observer.observe(video);
  });

  document.addEventListener("DOMContentLoaded", function () {
    gsap.registerPlugin(ScrollTrigger);

    const animation = lottie.loadAnimation({
      container: document.querySelector(".atomic-lottie"),
      renderer: "svg",
      loop: false,
      autoplay: false,
      path: "https://raw.githubusercontent.com/tushar-the-dev/Atomic_Capital/refs/heads/main/hosting/Atomic-lottie.json",
    });

    animation.addEventListener("DOMLoaded", () => {
      requestAnimationFrame(() => {
        const atomicLottie = document.querySelector(".atomic-lottie");

        const halfLottieHeight = atomicLottie.offsetHeight * 0.5;

        atomicLottie.style.top = `calc(50% - ${halfLottieHeight}px)`;

        const totalFrames = animation.totalFrames;

        const playhead = { frame: 0 };

        gsap.to(playhead, {
          frame: totalFrames - 1,
          ease: "none",
          scrollTrigger: {
            trigger: ".atomic-lottie-container",
            start: `top 50%`,
            end: `bottom center-=${halfLottieHeight}`,
            scrub: true,
            // pin: ".atomic-lottie",
            // anticipatePin: 1,
            // markers: true,
          },
          onUpdate: () => {
            animation.goToAndStop(playhead.frame, true);
          },
        });

        ScrollTrigger.refresh();
      });
    });
  });

  document.addEventListener("DOMContentLoaded", () => {
    gsap.registerPlugin(ScrollTrigger);

    const masks = gsap.utils.toArray(".mask-item");
    const contents = gsap.utils.toArray(".engagement-section");

    // initial mask
    gsap.set(masks, { opacity: 0 });
    // gsap.set(masks[0], { opacity: 1 });

    // switch masks based on content scroll
    contents.forEach((content, i) => {
      ScrollTrigger.create({
        trigger: content,
        start: "top center",
        end: "bottom bottom",

        onEnter: () => {
          gsap.to(masks[i], { opacity: 1, duration: 0.5 });
          if (i > 0) gsap.to(masks[i - 1], { opacity: 0, duration: 0.5 });
        },

        onEnterBack: () => {
          gsap.to(masks[i], { opacity: 1, duration: 0.5 });
          if (i < masks.length - 1) {
            gsap.to(masks[i + 1], { opacity: 0, duration: 0.5 });
          }
        },
        onLeaveBack: () => {
          if (i === 0) {
            gsap.to(masks[0], { opacity: 0, duration: 0.5 });
          }
        },
      });
    });
  });

  //Graph
  document.addEventListener("DOMContentLoaded", function () {
    const cardsWrapper = document.querySelector(".how-we-build-cards-wrapper");
    const cardsBlocks = cardsWrapper.querySelector(".how-we-build-card-blocks");
    const cards = cardsBlocks.querySelectorAll(".how-we-build-card-block");

    const blocks = document.querySelectorAll(".graph-path-block");
    const textLabels = [...blocks].map((_, i) =>
      document.querySelector(`#block-label-${i + 1}`)
    );

    const TOTAL_BLOCKS = blocks.length;
    const progressSteps = [...blocks].map((_, i) => i / (TOTAL_BLOCKS - 1));
    const TOLERANCE = 0.01;

    textLabels.forEach((label) => {
      if (label) gsap.set(label, { opacity: 0 });
    });

    const cardsWrapperWidth = cardsBlocks.scrollWidth;
    const lastCardWidth = cards[5].offsetWidth;
    // const TOTAL_BLOCKS = 6;
    const cardsWrapperShift = cardsWrapperWidth - lastCardWidth;

    //-------progress-bar
    const progressLabelsWrapper = document.querySelector(".progress-labels");
    const progressLabels =
      progressLabelsWrapper.querySelectorAll(".progress-label");

    const firstProgressLabelWidth = progressLabels[0].offsetWidth;

    gsap.set(".svg-progress-bar", {
      width: firstProgressLabelWidth,
      ease: "power1.out",
      duration: 0.5,
    });

    // how far cards need to travel in total
    // const TOTAL_CARD_SHIFT = lastcardWidth * (TOTAL_BLOCKS - 1);

    gsap.registerPlugin(ScrollTrigger);

    // const paths = [...document.querySelectorAll("#barsSvg path")];
    const TOTAL_STEPS = 6;
    const STEP = 1 / TOTAL_STEPS;

    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: ".section_how_we_build",
        start: "top top",
        end: "bottom bottom",
        scrub: true,
        // markers: true,
        //   snap: {
        //   snapTo: 1/6,
        //   duration: 0.4,
        //   ease: "power2.out",
        //   delay: 0
        // },

        onUpdate(self) {
          const progress = self.progress;

          textLabels.forEach((label, i) => {
            if (!label) return;

            const isActive = Math.abs(progress - progressSteps[i]) < TOLERANCE;

            gsap.set(label, {
              opacity: isActive ? 1 : 0,
            });
          });
        },
      },
    });

    // paths.forEach((path, i) => {
    //   const stroke = path.getAttribute("stroke");
    //   if (!stroke || !stroke.startsWith("url")) return;

    //   const gradientId = stroke.match(/#([^)]+)/)?.[1];
    //   if (!gradientId) return;

    //   const gradient = document.getElementById(gradientId);
    //   if (!gradient) return;

    //   const stops = gradient.querySelectorAll("stop");
    //   if (stops.length < 2) return;

    //   const [topStop, bottomStop] = stops;

    //   // Initial state
    //   gsap.set(topStop, { stopOpacity: 0.2 });
    //   gsap.set(bottomStop, { stopOpacity: 0.05 });

    //   // ðŸ‘‡ one path per scroll segment
    //   tl.to(topStop, {
    //     stopOpacity: 1,
    //     ease: "none",
    //     duration: 1,
    //   });

    //   tl.to(
    //     bottomStop,
    //     {
    //       stopOpacity: 0,
    //       ease: "none",
    //       duration: 1,
    //     },
    //     "<"
    //   ); // run together with topStop

    // });

    /* ----------------------------------------
   1ï¸âƒ£ FILL BLOCK 1 IMMEDIATELY (NO ANIMATION)
----------------------------------------- */
    (() => {
      const firstBlock = blocks[0];
      if (!firstBlock) return;

      firstBlock.querySelectorAll("path").forEach((path) => {
        const stroke = path.getAttribute("stroke");
        if (!stroke?.startsWith("url")) return;

        const gradientId = stroke.match(/#([^)]+)/)?.[1];
        const gradient = document.getElementById(gradientId);
        if (!gradient) return;

        const stops = gradient.querySelectorAll("stop");
        if (stops.length < 2) return;

        const [topStop, bottomStop] = stops;

        gsap.set(topStop, { stopOpacity: 1 });
        gsap.set(bottomStop, { stopOpacity: 0 });
      });
    })();

    /* ----------------------------------------
   2ï¸âƒ£ ANIMATE FROM BLOCK 2 ONWARDS
----------------------------------------- */
    blocks.forEach((block, blockIndex) => {
      if (blockIndex === 0) return; // ðŸ‘ˆ skip block 1

      block.querySelectorAll("path").forEach((path) => {
        const stroke = path.getAttribute("stroke");
        if (!stroke?.startsWith("url")) return;

        const gradientId = stroke.match(/#([^)]+)/)?.[1];
        const gradient = document.getElementById(gradientId);
        if (!gradient) return;

        const stops = gradient.querySelectorAll("stop");
        if (stops.length < 2) return;

        const [topStop, bottomStop] = stops;

        // Initial (empty) state for animated blocks
        gsap.set(topStop, { stopOpacity: 0.2 });
        gsap.set(bottomStop, { stopOpacity: 0.05 });

        // Animate fill
        tl.to(topStop, {
          stopOpacity: 1,
          ease: "none",
          duration: 1,
        });

        tl.to(
          bottomStop,
          {
            stopOpacity: 0,
            ease: "none",
            duration: 1,
          },
          "<"
        );
      });
    });

    //       //-----------------------
    tl.to(
      cardsBlocks,
      {
        x: -cardsWrapperShift,
        ease: "none",
        duration: tl.duration(), // ðŸ‘ˆ spans entire timeline
      },
      0
      // ðŸ‘ˆ start at beginning
    );

    //       //------------------------

    // âœ… Add progress bar synced to full timeline
    tl.to(
      ".svg-progress-bar",
      {
        width: "100%",
        ease: "none",
        duration: tl.duration(), // match entire timeline
      },
      0
    );
  });
</script>
